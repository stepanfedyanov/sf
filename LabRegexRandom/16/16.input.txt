#   ICU regular expression test cases.
#
#   format:   one test case per line,
#               <test case>    =  <pattern>   <flags>  <match string>  [# comment]
#               <pattern>      =  "<regular expression pattern>"
#               <match string> =  "<tagged string>"
#                                 the quotes on the pattern and match string can be " or ' or /
#               <tagged string> = text, with the start and end of each
#                                 capture group tagged with <n>...</n>.  The overall match,
#                                 if any, is group 0, as in <0>matched text</0>
#                                  A region can be specified with <r>...</r> tags.
#                                 Standard ICU unescape will be applied, allowing \u, \U, etc. to appear.
#
#               <flags>         = any combination of
#                                   i      case insensitive match
#                                   x      free spacing and comments
#                                   s      dot-matches-all mode
#                                   m      multi-line mode.  
#                                            ($ and ^ match at embedded new-lines)
#                                   D      Unix Lines mode (only recognize 0x0a as new-line)
#                                   Q      UREGEX_LITERAL flag.  Entire pattern is literal string.
#                                   v      If icu configured without break iteration, this
#                                          regex test pattern should not compile.
#                                   e      set the UREGEX_ERROR_ON_UNKNOWN_ESCAPES flag
#                                   d      dump the compiled pattern
#                                   t      trace operation of match engine.
#                                   2-9    a digit between 2 and 9, specifies the number of
#                                          times to execute find().  The expected results are
#                                          for the last find() in the sequence.
#                                   G      Only check match / no match.  Do not check capture groups.
#                                   E      Pattern compilation error expected
#                                   L      Use LookingAt() rather than find()
#                                   M      Use matches() rather than find().
#
#                                   a      Use non-Anchoring Bounds.
#                                   b      Use Transparent Bounds.
#                                          The a and b options only make a difference if
#                                          a <r>region</r> has been specified in the string.
#                                   z|Z    hitEnd was expected(z) or not expected (Z).
#                                          With neither, hitEnd is not checked.
#                                   y|Y    Require End expected(y) or not expected (Y).
#
#                                 White space must be present between the flags and the match string.
#

# Look-ahead expressions
#
"(?!0{5})(\d{5})"              "<0><1>00001</1></0>zzzz"
"(?!0{5})(\d{5})z"             "<0><1>00001</1>z</0>zzz"
"(?!0{5})(\d{5})(?!y)"         "<0><1>00001</1></0>zzzz"
"abc(?=def)"                   "<0>abc</0>def"
"(.*)(?=c)"                    "<0><1>ab</1></0>cdef"

"(?:.*)(?=c)"                  "<r>ab</r>cdef"
"(?:.*)(?=c)"             b    "<r><0>ab</0></r>cdef"      # transparent bounds
"(?:.*)(?=c)"             bM   "<r><0>ab</0></r>cdef"      # transparent bounds

"(?:.*)(?=(c))"           b    "<0>ab</0><1>c</1>def"      # Capture in look-ahead
"(?=(.)\1\1)\1"                "abcc<0><1>d</1></0>ddefg"  # Backrefs to look-ahead capture

".(?!\p{L})"                   "abc<0>d</0> "              # Negated look-ahead
".(?!(\p{L}))"                 "abc<0>d</0> "              # Negated look-ahead, no capture
                                                           #   visible outside of look-ahead
"and(?=roid)"            L     "<0>and</0>roid"
"and(?=roid)"            M     "<r>and</r>roid"
"and(?=roid)"            bM    "<r><0>and</0></r>roid"

"and(?!roid)"            L     "<0>and</0>roix"
"and(?!roid)"            L     "android"

"and(?!roid)"            M     "<r><0>and</0></r>roid"     # Opaque bounds
"and(?!roid)"            bM    "<r>and</r>roid"
"and(?!roid)"            bM    "<r><0>and</0></r>roix"

#
# Negated Lookahead, various regions and region transparency
#
"abc(?!def)"                   "<0>abc</0>xyz"
"abc(?!def)"                   "abcdef"
"abc(?!def)"                   "<r><0>abc</0></r>def"
"abc(?!def)"              b    "<r>abc</r>def"
"abc(?!def)"              b    "<r><0>abc</0></r>xyz"

#
# Nested Lookahead / Behind
#
"one(?=(?:(?!<out>).)*</out>)"  "<out><0>one</0> stuff</out>"
"one(?=(?:(?!<out>).)*</out>)"  "<out>one  <out></out>"

# More nesting lookaround: pattern matches "qq" when not preceded by 'a' and followed by 'z'
"(?<!a(?!...z))qq"               "<0>qq</0>c"
"(?<!a(?!...z))qq"               "f<0>qq</0>c"
"(?<!a(?!...z))qq"               "aqqz"

# More nested lookaround: match any two chars preceded and followed by an upper case letter.
# With gratuitious nesting of look-arounds and capture from the look-arounds.

"(?=(?<=(\p{Lu})(?=..(\p{Lu})))).."     "<1>A</1><0>jk</0><2>B</2>"
"(?=(?<=(\p{Lu})(?=..(\p{Lu})))).."     "ajkB"
"(?=(?<=(\p{Lu})(?=..(\p{Lu})))).."     "Ajkb"

# Nested lookaround cases from bug ICU-20564
"(?<=(?<=((?=)){0}+))"         "<0></0>abc"
"(?<=c(?<=c((?=c)){1}+))"      "c<0><1></1></0>cc"

#
#  Anchoring Bounds
#
"^def$"                        "abc<r><0>def</0></r>ghi"           # anchoring (default) bounds
"^def$"                  a     "abc<r>def</r>ghi"                  # non-anchoring bounds
"^def"                   a     "<r><0>def</0></r>ghi"              # non-anchoring bounds
"def$"                   a     "abc<r><0>def</0></r>"              # non-anchoring bounds

"^.*$"                   m     "<0>line 1</0>\n line 2"
"^.*$"                   m2    "line 1\n<0> line 2</0>"
"^.*$"                   m3    "line 1\n line 2"
"^.*$"                   m     "li<r><0>ne </0></r>1\n line 2"     # anchoring bounds
"^.*$"                   m2    "li<r>ne </r>1\n line 2"            # anchoring bounds
"^.*$"                  am     "li<r>ne </r>1\n line 2"            # non-anchoring bounds
"^.*$"                  am     "li\n<r><0>ne </0></r>\n1\n line 2" # non-anchoring bounds
